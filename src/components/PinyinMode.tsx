import React, { useState, useCallback, useEffect, useRef } from 'react';
import styled from 'styled-components';
import { motion, AnimatePresence } from 'framer-motion';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { InputSystem } from './InputSystem';
import { AnswerDisplay } from './AnswerDisplay';
import { BottomShortcutBar } from './BottomShortcutBar';
import { ShareCard } from './ShareCard';
import { ExerciseSidebar } from './ExerciseSidebar';
import { getAllSegmentsFromCourse, fetchExerciseSegments } from '../utils/courseAPI';
import { removeTrailingPunctuation } from '../utils/textProcessing';
import { startPractice, completePractice } from '../utils/segmentAPI';

const GameContainer = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #18181b 0%, #27272a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  position: relative;
  margin-left: 300px; /* ‰∏∫Â∑¶‰æßsidebarÁïôÂá∫Á©∫Èó¥ */
`;

const BackButton = styled(motion.button)`
  position: absolute;
  top: 30px;
  left: 30px;
  background: linear-gradient(135deg, #3f3f46 0%, #52525b 100%);
  border: 1px solid #52525b;
  border-radius: 12px;
  padding: 12px 18px;
  color: #d4d4d8;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
  
  &:hover {
    background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
    color: white;
    border-color: #0ea5e9;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
  }
`;


const ContentArea = styled(motion.div)`
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  position: relative;
`;

const StatusIndicator = styled(motion.div)<{ isActive: boolean }>`
  position: absolute;
  top: 30px;
  right: 30px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: ${props => props.isActive ? '#22c55e' : '#71717a'};
  box-shadow: 0 0 0 3px ${props => props.isActive ? 'rgba(34, 197, 94, 0.2)' : 'rgba(113, 113, 122, 0.2)'};
  transition: all 0.3s ease;
`;

const GameHint = styled(motion.div)`
  position: absolute;
  top: 30px;
  transform: translateX(-50%);
  font-size: 0.85rem;
  color: #a1a1aa;
  text-align: center;
  opacity: 0.8;
  z-index: 10;
`;

const StartScreen = styled(motion.div)`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  text-align: center;
  transform: translateY(-120px);
`;

const StartTitle = styled(motion.h1)`
  font-size: 3rem;
  font-weight: 600;
  color: #e4e4e7;
  margin-bottom: 20px;
  letter-spacing: -0.025em;
`;

const StartSubtitle = styled(motion.p)`
  font-size: 1.2rem;
  color: #a1a1aa;
  margin-bottom: 40px;
  max-width: 500px;
  line-height: 1.6;
`;

const KeyHint = styled(motion.div)`
  margin-top: 32px;
  font-size: 1.1rem;
  color: #d4d4d8;
  opacity: 1;
  font-weight: 500;
  background: linear-gradient(135deg, #3f3f46 0%, #52525b 100%);
  padding: 12px 24px;
  border-radius: 12px;
  border: 1px solid #52525b;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
  margin-bottom: 160px;
  
  &:hover {
    background: linear-gradient(135deg, #52525b 0%, #71717a 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }
`;

// ÂÆö‰πâÊñ∞ÁöÑÊï∞ÊçÆÁªìÊûÑÊé•Âè£
interface ExtendedExerciseSegment {
  id: string;
  content: string;
  pinyin: string[];
  pinyinWithoutTones: string[];
  translation?: string;
  audioUrl?: string;
  difficultyLevel: number;
  exerciseId: string; // Ê∑ªÂä†exercise IDÂºïÁî®
  exerciseIndex: number; // Ê∑ªÂä†exerciseÁ¥¢ÂºïÂºïÁî®
  // ÂÖ∂‰ªñÂèØËÉΩÈúÄË¶ÅÁöÑÂ≠óÊÆµ
  segmentIndex?: number;
  practiceOrder?: number;
  segmentType?: string;
  durationSeconds?: number;
  userProgress?: any;
}



export interface GameState {
  currentPhrase: {
    content: string;
    pinyin?: string | string[];
    pinyinWithoutTones?: string[]; // Ê∑ªÂä†‰∏çÂ∏¶Â£∞Ë∞ÉÁöÑÊãºÈü≥Â≠óÊÆµ
    translation?: string;
    id?: string;
    difficultyLevel?: number;
    audioUrl?: string; // Ê∑ªÂä†Èü≥È¢ëURLÂ≠óÊÆµ
  } | null;
  userInput: string;
  isPlaying: boolean;
  showAnswer: boolean;
  showPinyinHint: boolean;
  gameStarted: boolean;
  currentIndex: number;
  score: number;
  totalAttempts: number;
  correctAttempts: number;
  inputMode: 'pinyin';
  // Ê∑ªÂä†ÂÖ∂‰ªñÁº∫Â§±ÁöÑÂ≠óÊÆµ
  accuracy: number;
  speed: number;
  attempts: number;
  showResult: boolean;
  startTime: number | null;
  showShareCard: boolean;
  // Ê∑ªÂä†segmentÁõ∏ÂÖ≥Â≠óÊÆµ
  currentExerciseId?: string; // ÂΩìÂâçÁªÉ‰π†ID
  currentSegmentId?: string;  // ÂΩìÂâçsegment ID
  segmentStartTime?: number;  // segmentÂºÄÂßãÊó∂Èó¥
  practiceMode: 'listening' | 'speaking' | 'reading' | 'writing'; // ÁªÉ‰π†Ê®°Âºè
}

export const PinyinMode: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [allSegments, setAllSegments] = useState<ExtendedExerciseSegment[]>([]);
  const [exerciseList, setExerciseList] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasInitialized, setHasInitialized] = useState(false);
  
  const [gameState, setGameState] = useState<GameState>({
    currentPhrase: null,
    userInput: '',
    inputMode: 'pinyin',
    score: 0,
    accuracy: 0,
    speed: 0,
    isPlaying: false,
    showResult: false,
    startTime: null,
    attempts: 0,
    correctAttempts: 0,
    showShareCard: false,
    gameStarted: false,
    showAnswer: false,
    showPinyinHint: false,
    currentIndex: 0,
    totalAttempts: 0,
    practiceMode: 'listening', // ÈªòËÆ§‰∏∫Âê¨ÂäõÁªÉ‰π†Ê®°Âºè
  });

  const audioRef = useRef<HTMLAudioElement | null>(null);
  const secondAudioRef = useRef<HTMLAudioElement | null>(null);

  // ËÆ°ÁÆóexerciseËøõÂ∫¶ÁöÑÂáΩÊï∞
  const calculateExerciseProgress = useCallback((exercise: any) => {
    const segments = exercise.segments || [];
    const totalSegments = segments.length;
    const completedSegments = segments.filter((s: any) => s.userProgress?.isCompleted).length;
    const progressPercentage = totalSegments > 0 ? (completedSegments / totalSegments) * 100 : 0;
    
    // Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
    console.log(`üîç ËÆ°ÁÆóExercise ${exercise.id} ËøõÂ∫¶:`, {
      exerciseTitle: exercise.title,
      totalSegments,
      completedSegments,
      progressPercentage,
      isCompleted: completedSegments === totalSegments,
      segments: segments.map((s: any) => ({
        id: s.id,
        isCompleted: s.userProgress?.isCompleted
      }))
    });
    
    return {
      progressPercentage,
      isCompleted: completedSegments === totalSegments,
      completedSegments,
      totalSegments
    };
  }, []);

  // Êõ¥Êñ∞exerciseËøõÂ∫¶ÁöÑÂáΩÊï∞
  const updateExerciseProgress = useCallback((exerciseId: string, newProgress: any) => {
    setExerciseList(prev => prev.map(ex => 
      ex.id === exerciseId 
        ? { ...ex, ...newProgress }
        : ex
    ));
  }, []);

  // Êõ¥Êñ∞segmentÁä∂ÊÄÅÁöÑÂáΩÊï∞
  const updateSegmentStatus = useCallback((exerciseId: string, segmentId: string, isCompleted: boolean) => {
    setExerciseList(prev => prev.map(ex => {
      if (ex.id === exerciseId) {
        const updatedSegments = ex.segments.map((seg: any) => 
          seg.id === segmentId 
            ? { ...seg, userProgress: { ...seg.userProgress, isCompleted } }
            : seg
        );
        
        const newProgress = calculateExerciseProgress({ ...ex, segments: updatedSegments });
        return { ...ex, segments: updatedSegments, ...newProgress };
      }
      return ex;
    }));
  }, [calculateExerciseProgress]);

      // Ëé∑ÂèñÁªÉ‰π†Êï∞ÊçÆÔºàÊîØÊåÅ‰∏§ÁßçURLÂèÇÊï∞Ôºâ
  useEffect(() => {
    if (hasInitialized) return;
    
    // ‰ºòÂÖà‰ΩøÁî® courseIdÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂ∞ùËØï‰ΩøÁî® exercises
    const courseId = searchParams.get('courseId');
    const exercisesParam = searchParams.get('exercises');
    
    if (!courseId && !exercisesParam) {
      setError('Áº∫Â∞ëÂøÖË¶ÅÁöÑÂèÇÊï∞ÔºöcourseId Êàñ exercises');
      return;
    }
    
    setHasInitialized(true);
    setLoading(true);
    setError(null);
    
    // Ê∏ÖÁ©∫‰πãÂâçÁöÑÊï∞ÊçÆÔºåÈÅøÂÖçÈáçÂ§ç
    setExerciseList([]);
    setAllSegments([]);
    
    const fetchData = async () => {
      try {
        let processedSegments: ExtendedExerciseSegment[] = [];
        
                 if (courseId) {
           // ‰ΩøÁî®Áªü‰∏ÄÁöÑÊé•Âè£
           console.log('üîç ‰ΩøÁî®Áªü‰∏ÄÊé•Âè£Ëé∑ÂèñÊï∞ÊçÆÔºåcourseId:', courseId);
           const response = await getAllSegmentsFromCourse(courseId);
           
           console.log('üìã APIÂìçÂ∫îÊï∞ÊçÆÁªìÊûÑ:', response);
           
           // ÂÖàÊî∂ÈõÜÊâÄÊúâÁöÑexercisesÂíåsegmentsÔºåÁÑ∂Âêé‰∏ÄÊ¨°ÊÄßËÆæÁΩÆ
           const exercisesWithProgress: any[] = [];
           
           for (const exercise of response.exercises) {
             console.log('üîç Â§ÑÁêÜexercise:', exercise);
             
             if (!exercise || !exercise.id) {
               console.error('‚ùå ExerciseÊï∞ÊçÆÂºÇÂ∏∏:', exercise);
               continue;
             }
             
             const segments = exercise.segments || [];
             
             const gameSegments = segments.map((segment: any) => {
               // ËøáÊª§ÊéâÊãºÈü≥Êï∞ÁªÑ‰∏≠ÁöÑÊ†áÁÇπÁ¨¶Âè∑
               const filterPunctuation = (pinyinArray: string[]) => {
                 return pinyinArray.filter(syllable => 
                   syllable && !/[Ôºå„ÄÇÔºÅÔºü„ÄÅÔºõÔºö""''ÔºàÔºâ„Ää„Äã„Äê„Äë‚Äî‚Ä¶¬∑ÔΩû]/.test(syllable)
                 );
               };
               
               return {
                 id: segment.id,
                 content: removeTrailingPunctuation(segment.content || ''),
                 pinyin: filterPunctuation(segment.pinyinWithTones || []),
                 pinyinWithoutTones: filterPunctuation(segment.pinyinWithoutTones || []),
                 translation: segment.translation,
                 audioUrl: segment.audioUrl,
                 difficultyLevel: segment.difficultyLevel,
                 exerciseId: exercise.id,
                 exerciseIndex: (exercise.orderIndex || 1) - 1,
                 segmentIndex: segment.segmentIndex,
                 practiceOrder: segment.practiceOrder,
                 segmentType: segment.segmentType,
                 durationSeconds: segment.durationSeconds,
                 userProgress: segment.userProgress,
               };
             });
             
             processedSegments.push(...gameSegments);
             console.log(`üìö Exercise ${exercise.id}: Ê∑ªÂä†‰∫Ü ${gameSegments.length} ‰∏™segments`);
             
             // ËÆ°ÁÆóexerciseËøõÂ∫¶Âπ∂Ê∑ªÂä†Âà∞‰∏¥Êó∂Êï∞ÁªÑ
             const exerciseProgress = calculateExerciseProgress(exercise);
             const exerciseWithProgress = {
               ...exercise,
               ...exerciseProgress,
               isCurrent: false // Á®çÂêéËÆæÁΩÆÂΩìÂâçexercise
             };
             exercisesWithProgress.push(exerciseWithProgress);
           }
           
           // ‰∏ÄÊ¨°ÊÄßËÆæÁΩÆÊâÄÊúâexercisesÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
           setExerciseList(exercisesWithProgress);
        } else if (exercisesParam) {
          // ÂÖºÂÆπÊóßÁöÑÊé•Âè£Ôºà‰∏¥Êó∂ÊñπÊ°àÔºâ
          console.log('üîç ‰ΩøÁî®ÂÖºÂÆπÊé•Âè£Ëé∑ÂèñÊï∞ÊçÆÔºåexercises:', exercisesParam);
          const rawExercises = JSON.parse(exercisesParam);
          
          for (const exercise of rawExercises) {
            try {
              const segments = await fetchExerciseSegments(exercise.id);
              if (segments && segments.length > 0) {
                const gameSegments = segments.map((segment: any) => ({
                  ...segment,
                  content: removeTrailingPunctuation(segment.chineseText || segment.content || ''),
                  exerciseId: exercise.id,
                  exerciseIndex: exercise.orderIndex - 1,
                }));
                processedSegments.push(...gameSegments);
              }
            } catch (err) {
              console.error(`Failed to fetch segments for exercise ${exercise.id}:`, err);
            }
          }
        }
        
        setAllSegments(processedSegments);
        
        if (processedSegments.length > 0) {
          const firstSegment = processedSegments[0];
          
          // ËÆæÁΩÆÂΩìÂâçexerciseÁä∂ÊÄÅ
          setExerciseList(prev => prev.map(ex => ({
            ...ex,
            isCurrent: ex.id === firstSegment.exerciseId
          })));
          
          setGameState(prev => ({
            ...prev,
            currentPhrase: {
              content: firstSegment.content || '',
              pinyin: firstSegment.pinyin,
              pinyinWithoutTones: firstSegment.pinyinWithoutTones,
              translation: firstSegment.translation || '',
              id: firstSegment.id,
              difficultyLevel: firstSegment.difficultyLevel,
              audioUrl: firstSegment.audioUrl || '',
            },
            currentExerciseId: firstSegment.exerciseId,
            currentSegmentId: firstSegment.id,
            segmentStartTime: Date.now(),
          }));
        } else {
          setError('Ê≤°ÊúâÊâæÂà∞ÂèØÁî®ÁöÑÁªÉ‰π†Êï∞ÊçÆ');
        }
      } catch (err) {
        console.error('Failed to fetch data:', err);
        setError('Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [searchParams, hasInitialized]);

  // ÂÅúÊ≠¢ÊâÄÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥È¢ë
  const stopAllAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      audioRef.current = null;
    }
    if (secondAudioRef.current) {
      secondAudioRef.current.pause();
      secondAudioRef.current.currentTime = 0;
      secondAudioRef.current = null;
    }
    setGameState(prev => ({ ...prev, isPlaying: false }));
  }, []);

  const playAudioTwice = useCallback((audioUrl: string) => {
    // ÂÖàÂÅúÊ≠¢‰πãÂâçÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // ÂàõÂª∫Êñ∞ÁöÑÈü≥È¢ëÂØπË±°Âπ∂‰øùÂ≠òÂºïÁî®
    audioRef.current = new Audio(audioUrl);
    audioRef.current.volume = 0.7;
    
    setGameState(prev => ({ ...prev, isPlaying: true }));
    
    // Êí≠ÊîæÁ¨¨‰∏ÄÈÅç
    audioRef.current.play().then(() => {
      if (audioRef.current) {
        audioRef.current.onended = () => {
          // Á¨¨‰∏ÄÈÅçÁªìÊùüÔºåÁ≠âÂæÖ1ÁßíÂêéÊí≠ÊîæÁ¨¨‰∫åÈÅç
          setTimeout(() => {
            secondAudioRef.current = new Audio(audioUrl);
            secondAudioRef.current.volume = 0.7;
            secondAudioRef.current.play();
            secondAudioRef.current.onended = () => {
              setGameState(prev => ({ ...prev, isPlaying: false }));
              secondAudioRef.current = null;
            };
          }, 1000);
          audioRef.current = null;
        };
      }
    }).catch(() => {
      // Êí≠ÊîæÂ§±Ë¥•Êó∂ÈáçÁΩÆÁä∂ÊÄÅ
      setGameState(prev => ({ ...prev, isPlaying: false }));
      audioRef.current = null;
    });
  }, [stopAllAudio]);

  const startGame = useCallback(async () => {
    // Á°Æ‰øùÊúâÁªÉ‰π†Êï∞ÊçÆÊâçËÉΩÂºÄÂßãÊ∏∏Êàè
    if (allSegments.length === 0) {
      console.warn('No exercises available to start game');
      return;
    }
    
    setGameState(prev => ({
      ...prev,
      gameStarted: true,
    }));
    
    // ËÆ∞ÂΩïËøõÂÖ•segment
    if (gameState.currentExerciseId && gameState.currentSegmentId) {
      try {
        await startPractice(
          gameState.currentExerciseId, 
          gameState.currentSegmentId, 
          gameState.practiceMode
        );
        console.log('Successfully started practice:', gameState.currentSegmentId);
      } catch (error) {
        console.error('Failed to start practice:', error);
        // ‰∏çÂΩ±ÂìçÊ∏∏ÊàèËøõË°åÔºåÂè™ËÆ∞ÂΩïÈîôËØØ
      }
    }
    
    // Âª∂Ëøü‰∏Ä‰∏ãÁÑ∂ÂêéËá™Âä®Êí≠ÊîæËØ≠Èü≥‰∏§ÈÅç
    setTimeout(() => {
      if (gameState.currentPhrase?.audioUrl) {
        playAudioTwice(gameState.currentPhrase.audioUrl);
      }
    }, 500);
  }, [playAudioTwice, gameState.currentPhrase?.audioUrl, allSegments.length, gameState.currentExerciseId, gameState.currentSegmentId, gameState.practiceMode]);

  // Âø´Êç∑ÈîÆÂ§ÑÁêÜÂáΩÊï∞
  const handlePlayAudio = useCallback(() => {
    if (!gameState.isPlaying && gameState.currentPhrase?.audioUrl) {
      playAudioTwice(gameState.currentPhrase.audioUrl);
    }
  }, [gameState.currentPhrase?.audioUrl, gameState.isPlaying, playAudioTwice]);

  const handleMaster = useCallback(() => {
    // TODO: Implement master functionality
    console.log('Mark word as mastered');
  }, []);

  const handleNewWord = useCallback(() => {
    // TODO: Implement new word functionality
    console.log('Mark as new word');
  }, []);

  const handleSkip = useCallback(() => {
    // ÂÅúÊ≠¢ÂΩìÂâçÊí≠ÊîæÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // Ë∑≥ËøáÂΩìÂâçÈ¢òÁõÆÔºåÁõ¥Êé•ËøõÂÖ•‰∏ã‰∏ÄÈ¢ò
    if (allSegments.length > 0) {
      const currentIndex = allSegments.findIndex(ex => ex.id === gameState.currentPhrase?.id);
      const nextIndex = (currentIndex + 1) % allSegments.length;
      const newPhrase = allSegments[nextIndex];
      
      setGameState(prev => ({
        ...prev,
        currentPhrase: {
          content: newPhrase.content || '',
          pinyin: newPhrase.pinyin,
          pinyinWithoutTones: newPhrase.pinyinWithoutTones,
          translation: newPhrase.translation || '',
          id: newPhrase.id,
          difficultyLevel: newPhrase.difficultyLevel,
          audioUrl: newPhrase.audioUrl || '',
        },
        userInput: '',
        showResult: false,
        startTime: null,
        isPlaying: false,
        showAnswer: false,
        // Êõ¥Êñ∞segmentÂíåexercise‰ø°ÊÅØ
        currentExerciseId: newPhrase.exerciseId,
        currentSegmentId: newPhrase.id,
        segmentStartTime: Date.now(),
      }));
      
      // Ëá™Âä®Êí≠ÊîæÊñ∞È¢òÁõÆÁöÑËØ≠Èü≥‰∏§ÈÅç
      if (newPhrase.audioUrl) {
        setTimeout(() => {
          playAudioTwice(newPhrase.audioUrl!);
        }, 500);
      }
    }
  }, [stopAllAudio, playAudioTwice, allSegments, gameState.currentPhrase?.id]);

  const handleSubmitShortcut = useCallback(() => {
    // TODO: Implement submit functionality
    console.log('Shortcut submit');
  }, []);

  const handleShowAnswer = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      showAnswer: !prev.showAnswer
    }));
  }, []);

  // ÁõëÂê¨ÈîÆÁõò‰∫ã‰ª∂Êù•ÂºÄÂßãÊ∏∏Êàè
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (!gameState.gameStarted && allSegments.length > 0 && (e.code === 'Space' || e.code === 'Enter')) {
        e.preventDefault();
        startGame();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState.gameStarted, startGame, allSegments.length]);

  // ÁõëÂê¨Ê∏∏ÊàèÂÜÖÁöÑÂø´Êç∑ÈîÆ
  useEffect(() => {
    const handleShortcutKeys = (e: KeyboardEvent) => {
      if (!gameState.gameStarted) return;

      // Ctrl + ' - Êí≠ÊîæÂèëÈü≥
      if (e.ctrlKey && e.key === "'" && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handlePlayAudio();
        return;
      }

      // Ctrl + M - ÊéåÊè°
      if (e.ctrlKey && e.key === 'm' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleMaster();
        return;
      }

      // Ctrl + N - ÁîüËØç
      if (e.ctrlKey && e.key === 'n' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleNewWord();
        return;
      }

      // Ctrl + S - ÊòæÁ§∫Á≠îÊ°à
      if (e.ctrlKey && e.key === 's' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleShowAnswer();
        return;
      }
    };

    window.addEventListener('keydown', handleShortcutKeys);
    return () => window.removeEventListener('keydown', handleShortcutKeys);
  }, [gameState.gameStarted, handlePlayAudio, handleMaster, handleNewWord, handleShowAnswer]);

  const checkAnswer = useCallback(async () => {
    // ÂÅúÊ≠¢ÂΩìÂâçÊí≠ÊîæÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // ËÆ∞ÂΩïÂÆåÊàêsegment
    if (gameState.currentExerciseId && gameState.currentSegmentId && gameState.segmentStartTime) {
      try {
        const timeSpentSeconds = Math.floor((Date.now() - gameState.segmentStartTime) / 1000);
        await completePractice(
          gameState.currentExerciseId, 
          gameState.currentSegmentId, 
          gameState.practiceMode,
          timeSpentSeconds
        );
        console.log('Successfully completed practice:', gameState.currentSegmentId, 'Time spent:', timeSpentSeconds, 'seconds');
        
        // Êõ¥Êñ∞segmentÁä∂ÊÄÅÂíåexerciseËøõÂ∫¶
        updateSegmentStatus(gameState.currentExerciseId, gameState.currentSegmentId, true);
      } catch (error) {
        console.error('Failed to complete practice:', error);
        // ‰∏çÂΩ±ÂìçÊ∏∏ÊàèËøõË°åÔºåÂè™ËÆ∞ÂΩïÈîôËØØ
      }
    }
    
    // Áõ¥Êé•ËøõÂÖ•‰∏ã‰∏ÄÈ¢òÔºå‰∏çÊòæÁ§∫ÂàÜÊï∞ÁªüËÆ°
    if (allSegments.length > 0) {
      const currentIndex = allSegments.findIndex(ex => ex.id === gameState.currentPhrase?.id);
      const nextIndex = (currentIndex + 1) % allSegments.length;
      const newPhrase = allSegments[nextIndex];
      
      setGameState(prev => ({
        ...prev,
        currentPhrase: {
          content: newPhrase.content || '',
          pinyin: newPhrase.pinyin,
          pinyinWithoutTones: newPhrase.pinyinWithoutTones,
          translation: newPhrase.translation || '',
          id: newPhrase.id,
          difficultyLevel: newPhrase.difficultyLevel,
          audioUrl: newPhrase.audioUrl || '',
        },
        userInput: '',
        showResult: false,
        startTime: null,
        isPlaying: false,
        showAnswer: false, // Hide answer when starting new question
        // Êõ¥Êñ∞segmentÂíåexercise‰ø°ÊÅØ
        currentExerciseId: newPhrase.exerciseId,
        currentSegmentId: newPhrase.id,
        segmentStartTime: Date.now(),
      }));
      
      // Ëá™Âä®Êí≠ÊîæÊñ∞È¢òÁõÆÁöÑËØ≠Èü≥‰∏§ÈÅç
      if (newPhrase.audioUrl) {
        setTimeout(() => {
          playAudioTwice(newPhrase.audioUrl!);
        }, 500);
      }
      
      // ËÆ∞ÂΩïËøõÂÖ•Êñ∞ÁöÑsegment
      if (newPhrase.exerciseId && newPhrase.id) {
        try {
          await startPractice(
            newPhrase.exerciseId, 
            newPhrase.id, 
            gameState.practiceMode
          );
          console.log('Successfully entered new segment:', newPhrase.id);
        } catch (error) {
          console.error('Failed to enter new segment:', error);
        }
      }
    }
  }, [stopAllAudio, playAudioTwice, allSegments, gameState.currentPhrase?.id, gameState.currentExerciseId, gameState.currentSegmentId, gameState.segmentStartTime, gameState.practiceMode]);

  const closeShareCard = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      showShareCard: false,
    }));
  }, []);

  // Â§ÑÁêÜexerciseÈÄâÊã©
  const handleExerciseSelect = useCallback((exerciseId: string) => {
    // ÊâæÂà∞ÈÄâ‰∏≠ÁöÑexercise
    const selectedExercise = exerciseList.find(ex => ex.id === exerciseId);
    if (!selectedExercise) return;
    
    // ÊâæÂà∞ËØ•exerciseÁöÑÁ¨¨‰∏Ä‰∏™segment
    const firstSegment = allSegments.find(seg => seg.exerciseId === exerciseId);
    if (!firstSegment) return;
    
    // Êõ¥Êñ∞ÂΩìÂâçexerciseÁä∂ÊÄÅ
    setExerciseList(prev => prev.map(ex => ({
      ...ex,
      isCurrent: ex.id === exerciseId
    })));
    
    // Êõ¥Êñ∞Ê∏∏ÊàèÁä∂ÊÄÅ
    setGameState(prev => ({
      ...prev,
      currentPhrase: {
        content: firstSegment.content || '',
        pinyin: firstSegment.pinyin,
        pinyinWithoutTones: firstSegment.pinyinWithoutTones,
        translation: firstSegment.translation || '',
        id: firstSegment.id,
        difficultyLevel: firstSegment.difficultyLevel,
        audioUrl: firstSegment.audioUrl || '',
      },
      currentExerciseId: firstSegment.exerciseId,
      currentSegmentId: firstSegment.id,
      segmentStartTime: Date.now(),
      userInput: '',
      showResult: false,
      startTime: null,
      isPlaying: false,
      showAnswer: false,
    }));
    
    // Ëá™Âä®Êí≠ÊîæÊñ∞È¢òÁõÆÁöÑËØ≠Èü≥
    if (firstSegment.audioUrl) {
      setTimeout(() => {
        playAudioTwice(firstSegment.audioUrl!);
      }, 500);
    }
    
    // ËÆ∞ÂΩïËøõÂÖ•Êñ∞ÁöÑsegment
    if (firstSegment.exerciseId && firstSegment.id) {
      startPractice(firstSegment.exerciseId, firstSegment.id, gameState.practiceMode)
        .then(() => console.log('Successfully entered new segment:', firstSegment.id))
        .catch(error => console.error('Failed to enter new segment:', error));
    }
  }, [exerciseList, allSegments, playAudioTwice, gameState.practiceMode]);

  return (
    <>
      {/* Â∑¶‰æßExerciseÂàóË°® */}
      {exerciseList.length > 0 && (
        <ExerciseSidebar
          exercises={exerciseList}
          currentExerciseId={gameState.currentExerciseId || ''}
          onExerciseSelect={handleExerciseSelect}
        />
      )}
      
      <GameContainer>
        <BackButton
          onClick={() => navigate(-1)}
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        >
          ‚Üê Back
        </BackButton>

      {/* ÈöêËóèÊ®°ÂºèÊåáÁ§∫Âô®ÔºåÁïåÈù¢Êõ¥ÁÆÄÊ¥Å
      <ModeIndicator
        initial={{ opacity: 0, x: 20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.3 }}
      >
        ÊãºÈü≥Ê®°Âºè
      </ModeIndicator>
      */}

      {/* Âä†ËΩΩÁä∂ÊÄÅ */}
      {loading && (
        <ContentArea
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            style={{
              textAlign: 'center',
              color: '#a1a1aa',
              fontSize: '1.1rem'
            }}
          >
            Ê≠£Âú®Âä†ËΩΩÁªÉ‰π†Êï∞ÊçÆ...
          </motion.div>
        </ContentArea>
      )}

      {/* ÈîôËØØÁä∂ÊÄÅ */}
      {error && !loading && (
        <ContentArea
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            style={{
              textAlign: 'center',
              color: '#ef4444',
              fontSize: '1.1rem',
              padding: '20px',
              background: 'rgba(239, 68, 68, 0.1)',
              borderRadius: '12px',
              border: '1px solid rgba(239, 68, 68, 0.3)'
            }}
          >
            {error}
            <br />
            <button
              onClick={() => window.location.reload()}
              style={{
                marginTop: '10px',
                padding: '8px 16px',
                background: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: '6px',
                cursor: 'pointer'
              }}
            >
              ÈáçËØï
            </button>
          </motion.div>
        </ContentArea>
      )}

      {/* Ê∏∏ÊàèÂºÄÂßãÁïåÈù¢ */}
      {!gameState.gameStarted && !loading && !error && allSegments.length > 0 ? (
        <StartScreen
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        >
          <StartTitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.6 }}
          >
            Ready to Start?
          </StartTitle>
          
          <StartSubtitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.6 }}
          >
            Make learning Chinese fun and interactive
          </StartSubtitle>
          
          <KeyHint
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.8, duration: 0.6 }}
          >
            Press Space or Enter to begin
          </KeyHint>
        </StartScreen>
      ) : null}

      {/* Ê∏∏ÊàèÁïåÈù¢ */}
      {gameState.gameStarted && !loading && !error && allSegments.length > 0 && (
        <>
          <GameHint
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3, duration: 0.5 }}
          >
            Type in pinyin
          </GameHint>
          
          <StatusIndicator
            isActive={gameState.isPlaying}
            animate={{
              scale: gameState.isPlaying ? [1, 1.2, 1] : 1,
            }}
            transition={{
              duration: 1.5,
              repeat: gameState.isPlaying ? Infinity : 0,
            }}
          />
          
          <ContentArea
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ 
              duration: 0.8, 
              ease: "easeOut" as const
            }}
          >
            {/* Answer display */}
            <AnswerDisplay
              isVisible={gameState.showAnswer}
              phrase={gameState.currentPhrase ? {
                content: gameState.currentPhrase.content,
                pinyin: gameState.currentPhrase.pinyin,
                translation: gameState.currentPhrase.translation
              } : null}
            />

            <InputSystem
              currentPhrase={gameState.currentPhrase}
              userInput={gameState.userInput}
              onSubmit={checkAnswer}
              disabled={false}
            />
            
            <AnimatePresence mode="wait">
              {/* Removed ScoreBoard display for simplified game experience */}
            </AnimatePresence>
          </ContentArea>
          
          <AnimatePresence>
            {gameState.showShareCard && (
              <ShareCard
                score={gameState.score}
                accuracy={gameState.accuracy}
                speed={gameState.speed}
                phrase={gameState.currentPhrase ? {
                  id: gameState.currentPhrase.id || '',
                  content: gameState.currentPhrase.content,
                  pinyin: gameState.currentPhrase.pinyin,
                  pinyinWithoutTones: gameState.currentPhrase.pinyinWithoutTones,
                  translation: gameState.currentPhrase.translation,
                  audioUrl: gameState.currentPhrase.audioUrl,
                  difficultyLevel: gameState.currentPhrase.difficultyLevel
                } : null}
                onClose={closeShareCard}
              />
            )}
          </AnimatePresence>
          
          {/* Bottom shortcut bar */}
          <BottomShortcutBar
            onPlayAudio={handlePlayAudio}
            onMaster={handleMaster}
            onNewWord={handleNewWord}
            onSubmit={handleSubmitShortcut}
            onShowAnswer={handleShowAnswer}
            onSkip={handleSkip}
            mode="pinyin"
          />
        </>
      )}
      </GameContainer>
    </>
  );
};