import React, { useState, useCallback, useEffect, useRef } from 'react';
import styled from 'styled-components';
import { motion, AnimatePresence } from 'framer-motion';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { ChineseInputSystem } from './ChineseInputSystem';
import { BottomShortcutBar } from './BottomShortcutBar';
import { AnswerDisplay } from './AnswerDisplay';
import { gameAnalytics } from '../utils/analytics';
import { getAllSegmentsFromCourse, ExerciseSegment } from '../utils/courseAPI';
import { removeTrailingPunctuation } from '../utils/textProcessing';
import { startPractice, completePractice } from '../utils/segmentAPI';

const GameContainer = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #18181b 0%, #27272a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  position: relative;
`;

const BackButton = styled(motion.button)`
  position: absolute;
  top: 30px;
  left: 30px;
  background: linear-gradient(135deg, #3f3f46 0%, #52525b 100%);
  border: 1px solid #52525b;
  border-radius: 12px;
  padding: 12px 18px;
  color: #d4d4d8;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
  
  &:hover {
    background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
    color: white;
    border-color: #0ea5e9;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
  }
`;

const ContentArea = styled(motion.div)`
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  position: relative;
`;

const StatusIndicator = styled(motion.div)<{ isActive: boolean }>`
  position: absolute;
  top: 30px;
  right: 30px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: ${props => props.isActive ? '#22c55e' : '#71717a'};
  box-shadow: 0 0 0 3px ${props => props.isActive ? 'rgba(34, 197, 94, 0.2)' : 'rgba(113, 113, 122, 0.2)'};
  transition: all 0.3s ease;
`;

const GameHint = styled(motion.div)`
  position: absolute;
  top: 30px;
  transform: translateX(-50%);
  font-size: 0.85rem;
  color: #a1a1aa;
  text-align: center;
  opacity: 0.8;
  z-index: 10;
`;

const StartScreen = styled(motion.div)`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  text-align: center;
  transform: translateY(-120px);
`;

const StartTitle = styled(motion.h1)`
  font-size: 3rem;
  font-weight: 600;
  color: #e4e4e7;
  margin-bottom: 20px;
  letter-spacing: -0.025em;
`;

const StartSubtitle = styled(motion.p)`
  font-size: 1.2rem;
  color: #a1a1aa;
  margin-bottom: 40px;
  max-width: 500px;
`;

const KeyHint = styled(motion.div)`
  font-size: 1rem;
  color: #71717a;
  padding: 12px 24px;
  background: rgba(113, 113, 122, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(113, 113, 122, 0.2);
`;

const PinyinToggle = styled(motion.button)`
  position: absolute;
  top: 30px;
  right: 30px;
  background: linear-gradient(135deg, #3f3f46 0%, #52525b 100%);
  border: 1px solid #52525b;
  border-radius: 12px;
  padding: 12px 18px;
  color: #d4d4d8;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 500;
  
  &:hover {
    background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
    color: white;
    border-color: #0ea5e9;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
  }
  
  &.active {
    background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
    color: white;
    border-color: #0ea5e9;
  }
`;

// Êñ∞Â¢ûÔºöÁªÉ‰π†ËøõÂ∫¶Êé•Âè£
export interface ExerciseProgress {
  exercise: {
    id: string;
    title?: string; // Êîπ‰∏∫ÂèØÈÄâÔºåÂõ†‰∏∫ExerciseÊé•Âè£ÂèØËÉΩÊ≤°ÊúâtitleÂ≠óÊÆµ
    content: string;
    exerciseType?: string; // Êîπ‰∏∫ÂèØÈÄâ
    difficultyLevel: number;
    orderIndex: number;
  };
  segments: ExerciseSegment[];
  userProgress: {
    isCompleted: boolean;
    completedSegments: number;
    totalSegments: number;
    progressPercentage: number;
  };
}

// Êñ∞Â¢ûÔºöËØæÁ®ãÂÆåÊï¥Êï∞ÊçÆÊé•Âè£
export interface CourseCompleteData {
  course: {
    id: string;
    title: string;
    description?: string;
    orderIndex: number;
  };
  exercises: ExerciseProgress[];
}

// Êâ©Â±ïExerciseSegmentÊé•Âè£ÔºåÊ∑ªÂä†exerciseÁõ∏ÂÖ≥‰ø°ÊÅØ
interface ExtendedExerciseSegment extends ExerciseSegment {
  exerciseId: string; // Ê∑ªÂä†exercise IDÂºïÁî®
  exerciseIndex: number; // Ê∑ªÂä†exerciseÁ¥¢ÂºïÂºïÁî®
}

export interface GameState {
  currentPhrase: {
    content: string;
    pinyin?: string | string[];
    pinyinWithoutTones?: string[]; // Ê∑ªÂä†‰∏çÂ∏¶Â£∞Ë∞ÉÁöÑÊãºÈü≥Â≠óÊÆµ
    translation?: string;
    id?: string;
    difficultyLevel?: number;
    audioUrl?: string; // Ê∑ªÂä†Èü≥È¢ëURLÂ≠óÊÆµ
  } | null;
  userInput: string;
  isPlaying: boolean;
  showAnswer: boolean;
  showPinyinHint: boolean;
  gameStarted: boolean;
  currentIndex: number;
  score: number;
  totalAttempts: number;
  correctAttempts: number;
  inputMode: 'chinese';
  // Ê∑ªÂä†segmentÁõ∏ÂÖ≥Â≠óÊÆµ
  currentExerciseId?: string; // ÂΩìÂâçÁªÉ‰π†ID
  currentSegmentId?: string;  // ÂΩìÂâçsegment ID
  segmentStartTime?: number;  // segmentÂºÄÂßãÊó∂Èó¥
  practiceMode: 'listening' | 'speaking' | 'reading' | 'writing'; // ÁªÉ‰π†Ê®°Âºè
  // Êñ∞Â¢ûÔºöexerciseÁõ∏ÂÖ≥Â≠óÊÆµ
  currentExerciseIndex?: number; // ÂΩìÂâçexerciseÁ¥¢Âºï
  
  // Êñ∞Â¢ûÔºöËØæÁ®ãÂÆåÊàêÁõ∏ÂÖ≥Â≠óÊÆµ
  showCourseCompletion?: boolean; // ÊòØÂê¶ÊòæÁ§∫ËØæÁ®ãÂÆåÊàêÊèêÁ§∫
  courseCompleted?: boolean; // ËØæÁ®ãÊòØÂê¶Â∑≤ÂÆåÊàê
}

export const ChineseMode: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [allSegments, setAllSegments] = useState<ExtendedExerciseSegment[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasInitialized, setHasInitialized] = useState(false);
  
  const [gameState, setGameState] = useState<GameState>({
    currentPhrase: null,
    userInput: '',
    isPlaying: false,
    showAnswer: false,
    showPinyinHint: false,
    gameStarted: false,
    currentIndex: 0,
    score: 0,
    totalAttempts: 0,
    correctAttempts: 0,
    inputMode: 'chinese',
    practiceMode: 'listening', // ÈªòËÆ§‰∏∫Âê¨ÂäõÁªÉ‰π†Ê®°Âºè
    currentExerciseIndex: 0, // ÂΩìÂâçexerciseÁ¥¢Âºï
  });

  const audioRef = useRef<HTMLAudioElement | null>(null);
  const secondAudioRef = useRef<HTMLAudioElement | null>(null);

  // Ëé∑ÂèñÁªÉ‰π†Êï∞ÊçÆÔºà‰ΩøÁî®Áªü‰∏ÄÁöÑÊé•Âè£Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆÔºâ
  useEffect(() => {
    // Âè™Âú®ÁªÑ‰ª∂ÂàùÂßãÂåñÊó∂Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆÔºåÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ
    if (hasInitialized) return;
    
    const courseId = searchParams.get('courseId');
    if (!courseId) return;
    
    setHasInitialized(true);
    setLoading(true);
    setError(null);
    
    const fetchCourseData = async () => {
      try {
        // ‰ΩøÁî®Áªü‰∏ÄÁöÑÊé•Âè£Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆÔºåÈÅøÂÖçÂ§ö‰∏™segmentsËØ∑Ê±Ç
        const response = await getAllSegmentsFromCourse(courseId);
        
        // Â§ÑÁêÜÊâÄÊúâsegmentsÔºåÂéªÊéâÂè•Êú´Ê†áÁÇπ
        const processedSegments: ExtendedExerciseSegment[] = [];
        
        for (const exercise of response.exercises) {
          const segments = exercise.segments;
          
          // Â∞ÜÁâáÊÆµÊï∞ÊçÆËΩ¨Êç¢‰∏∫Ê∏∏ÊàèÈúÄË¶ÅÁöÑÊ†ºÂºè
          const gameSegments = segments.map((segment: any) => {
            // ÂéªÊéâÂè•Êú´Ê†áÁÇπ
            const cleanContent = removeTrailingPunctuation(segment.content || '');
            
            // ËøáÊª§ÊéâÊãºÈü≥Êï∞ÁªÑ‰∏≠ÁöÑÊ†áÁÇπÁ¨¶Âè∑
            const filterPunctuation = (pinyinArray: string[]) => {
              return pinyinArray.filter(syllable => 
                syllable && !/[Ôºå„ÄÇÔºÅÔºü„ÄÅÔºõÔºö""''ÔºàÔºâ„Ää„Äã„Äê„Äë‚Äî‚Ä¶¬∑ÔΩû]/.test(syllable)
              );
            };
            
            // Ëé∑ÂèñÊãºÈü≥Êï∞ÁªÑÔºåÁ°Æ‰øùÈïøÂ∫¶‰∏éÊ∏ÖÁêÜÂêéÁöÑÊñáÊú¨ÂåπÈÖç
            let cleanPinyin = filterPunctuation(segment.pinyinWithTones || []);
            let cleanPinyinWithoutTones = filterPunctuation(segment.pinyinWithoutTones || []);
            
            // Â¶ÇÊûúÊãºÈü≥Êï∞ÁªÑÈïøÂ∫¶‰∏éÊ∏ÖÁêÜÂêéÊñáÊú¨‰∏çÂåπÈÖçÔºåËøõË°åË∞ÉÊï¥
            if (cleanPinyin.length > cleanContent.length) {
              cleanPinyin = cleanPinyin.slice(0, cleanContent.length);
              cleanPinyinWithoutTones = cleanPinyinWithoutTones.slice(0, cleanContent.length);
            }
            
            return {
              ...segment, // ‰øùÁïôÂéüÂßãsegmentÁöÑÊâÄÊúâÂ≠óÊÆµ
              content: cleanContent, // ‰ΩøÁî®ÂéªÊéâÂè•Êú´Ê†áÁÇπÁöÑÂÜÖÂÆπ
              pinyin: cleanPinyin, // Ë∞ÉÊï¥ÂêéÁöÑÂ∏¶Â£∞Ë∞ÉÊãºÈü≥
              pinyinWithoutTones: cleanPinyinWithoutTones, // Ë∞ÉÊï¥ÂêéÁöÑ‰∏çÂ∏¶Â£∞Ë∞ÉÊãºÈü≥
              exerciseId: exercise.id, // ‰ΩøÁî®Ê≠£Á°ÆÁöÑexercise ID
              exerciseIndex: exercise.orderIndex - 1, // ‰ΩøÁî®orderIndex‰Ωú‰∏∫exerciseÁ¥¢Âºï
            };
          });
          
          processedSegments.push(...gameSegments);
          
          // Ë∞ÉËØï‰ø°ÊÅØÔºöÊòæÁ§∫ÊØè‰∏™exerciseÁöÑsegments
          console.log(`üìö Exercise ${exercise.id} (orderIndex ${exercise.orderIndex}): Ê∑ªÂä†‰∫Ü ${gameSegments.length} ‰∏™segments`);
          gameSegments.forEach((seg: any) => {
            console.log(`   - Segment ${seg.id}: exerciseId=${seg.exerciseId}, exerciseIndex=${seg.exerciseIndex}`);
          });
        }
        
        setAllSegments(processedSegments);
        
        // ËÆæÁΩÆÁ¨¨‰∏Ä‰∏™ÁâáÊÆµ‰∏∫ÂΩìÂâçÁü≠ËØ≠
        if (processedSegments.length > 0) {
          const firstSegment = processedSegments[0];
          setGameState(prev => ({
            ...prev,
            currentPhrase: {
              content: firstSegment.content || '',
              pinyin: firstSegment.pinyin,
              pinyinWithoutTones: firstSegment.pinyinWithoutTones,
              translation: firstSegment.translation || '',
              id: firstSegment.id,
              difficultyLevel: firstSegment.difficultyLevel,
              audioUrl: firstSegment.audioUrl || '',
            },
            currentExerciseId: firstSegment.exerciseId,
            currentSegmentId: firstSegment.id,
            segmentStartTime: Date.now(),
            currentExerciseIndex: firstSegment.exerciseIndex,
          }));
        }
      } catch (err) {
        console.error('Failed to fetch course data:', err);
        setError('Ëé∑ÂèñËØæÁ®ãÊï∞ÊçÆÂ§±Ë¥•');
      } finally {
        setLoading(false);
      }
    };
    
    fetchCourseData();
  }, [searchParams, hasInitialized]);

  // ÂÅúÊ≠¢ÊâÄÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥È¢ë
  const stopAllAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      audioRef.current = null;
    }
    if (secondAudioRef.current) {
      secondAudioRef.current.pause();
      secondAudioRef.current.currentTime = 0;
      secondAudioRef.current = null;
    }
    setGameState(prev => ({ ...prev, isPlaying: false }));
  }, []);

  const playAudioTwice = useCallback((audioUrl: string) => {
    // ÂÖàÂÅúÊ≠¢‰πãÂâçÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // ÂàõÂª∫Êñ∞ÁöÑÈü≥È¢ëÂØπË±°Âπ∂‰øùÂ≠òÂºïÁî®
    audioRef.current = new Audio(audioUrl);
    audioRef.current.volume = 0.7;
    
    setGameState(prev => ({ ...prev, isPlaying: true }));
    
    // Êí≠ÊîæÁ¨¨‰∏ÄÈÅç
    audioRef.current.play().then(() => {
      if (audioRef.current) {
        audioRef.current.onended = () => {
          // Á¨¨‰∏ÄÈÅçÁªìÊùüÔºåÁ≠âÂæÖ1ÁßíÂêéÊí≠ÊîæÁ¨¨‰∫åÈÅç
          setTimeout(() => {
            secondAudioRef.current = new Audio(audioUrl);
            secondAudioRef.current.volume = 0.7;
            secondAudioRef.current.play();
            secondAudioRef.current.onended = () => {
              setGameState(prev => ({ ...prev, isPlaying: false }));
              secondAudioRef.current = null;
            };
          }, 1000);
          audioRef.current = null;
        };
      }
    }).catch(() => {
      // Êí≠ÊîæÂ§±Ë¥•Êó∂ÈáçÁΩÆÁä∂ÊÄÅ
      setGameState(prev => ({ ...prev, isPlaying: false }));
      audioRef.current = null;
    });
  }, [stopAllAudio]);

  const startGame = useCallback(async () => {
    // Á°Æ‰øùÊúâÁªÉ‰π†Êï∞ÊçÆÊâçËÉΩÂºÄÂßãÊ∏∏Êàè
    if (allSegments.length === 0) {
      console.warn('No exercises available to start game');
      return;
    }
    
    setGameState(prev => ({
      ...prev,
      gameStarted: true,
    }));
    
    // ËøΩË∏™Ê∏∏ÊàèÂºÄÂßã
    gameAnalytics.gameStart('chinese');
    
    // ËÆ∞ÂΩïËøõÂÖ•segment
    if (gameState.currentExerciseId && gameState.currentSegmentId) {
      try {
        await startPractice(
          gameState.currentExerciseId, 
          gameState.currentSegmentId, 
          gameState.practiceMode
        );
        console.log('Successfully started practice:', gameState.currentSegmentId);
      } catch (error) {
        console.error('Failed to start practice:', error);
        // ‰∏çÂΩ±ÂìçÊ∏∏ÊàèËøõË°åÔºåÂè™ËÆ∞ÂΩïÈîôËØØ
      }
    }
  }, [allSegments.length, gameState.currentExerciseId, gameState.currentSegmentId, gameState.practiceMode]);

  // Âø´Êç∑ÈîÆÂ§ÑÁêÜÂáΩÊï∞
  const handlePlayAudio = useCallback(() => {
    if (!gameState.isPlaying && gameState.currentPhrase?.audioUrl) {
      playAudioTwice(gameState.currentPhrase.audioUrl);
    }
  }, [gameState.currentPhrase, gameState.isPlaying, playAudioTwice]);

  const handleMaster = useCallback(() => {
    console.log('Mark word as mastered');
  }, []);

  const handleNewWord = useCallback(() => {
    console.log('Mark as new word');
  }, []);

  const handleSkip = useCallback(() => {
    // ÂÅúÊ≠¢ÂΩìÂâçÊí≠ÊîæÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // Ë∑≥ËøáÂΩìÂâçÈ¢òÁõÆÔºåÁõ¥Êé•ËøõÂÖ•‰∏ã‰∏ÄÈ¢ò
    if (allSegments.length > 0) {
      const currentIndex = allSegments.findIndex(ex => ex.id === gameState.currentPhrase?.id);
      const nextIndex = (currentIndex + 1) % allSegments.length;
      const newPhrase = allSegments[nextIndex];
      
      setGameState(prev => ({
        ...prev,
        currentPhrase: {
          content: newPhrase.content || newPhrase.chineseText || '',
          pinyin: newPhrase.pinyin,
          pinyinWithoutTones: newPhrase.pinyinWithoutTones,
          translation: newPhrase.translation || '',
          id: newPhrase.id,
          difficultyLevel: newPhrase.difficultyLevel,
          audioUrl: newPhrase.audioUrl || '',
        },
        userInput: '',
        showResult: false,
        startTime: null,
        isPlaying: false,
        showAnswer: false,
        // Êõ¥Êñ∞segmentÂíåexercise‰ø°ÊÅØ
        currentExerciseId: newPhrase.exerciseId,
        currentSegmentId: newPhrase.id,
        segmentStartTime: Date.now(),
        currentExerciseIndex: newPhrase.exerciseIndex,
      }));
      
      // Ëá™Âä®Êí≠ÊîæÊñ∞È¢òÁõÆÁöÑËØ≠Èü≥‰∏§ÈÅç
      if (newPhrase.audioUrl) {
        setTimeout(() => {
          playAudioTwice(newPhrase.audioUrl!);
        }, 500);
      }
    }
  }, [stopAllAudio, playAudioTwice, allSegments, gameState.currentPhrase?.id]);

  const handleSubmitShortcut = useCallback(() => {
    console.log('Shortcut submit');
  }, []);

  const handleShowAnswer = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      showAnswer: !prev.showAnswer
    }));
  }, []);

  const togglePinyinHint = useCallback(() => {
    setGameState(prev => {
      const newShowHint = !prev.showPinyinHint;
      // ËøΩË∏™ÊãºÈü≥ÊèêÁ§∫ÂàáÊç¢
      gameAnalytics.pinyinHintToggle(newShowHint);
      return {
        ...prev,
        showPinyinHint: newShowHint
      };
    });
  }, []);

  // ÁõëÂê¨ÈîÆÁõò‰∫ã‰ª∂Êù•ÂºÄÂßãÊ∏∏Êàè
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (!gameState.gameStarted && allSegments.length > 0 && (e.code === 'Space' || e.code === 'Enter')) {
        e.preventDefault();
        startGame();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState.gameStarted, startGame, allSegments.length]);

  // ÁõëÂê¨Ê∏∏ÊàèÂÜÖÁöÑÂø´Êç∑ÈîÆÂíåESCÈîÆ
  useEffect(() => {
    const handleShortcutKeys = (e: KeyboardEvent) => {
      // ESCÈîÆ - ËøîÂõûËØæÁ®ãÂåÖÈ°µÈù¢
      if (e.code === 'Escape') {
        e.preventDefault();
        navigate(-1);
        return;
      }

      if (!gameState.gameStarted) return;

      // Ctrl + ' - Êí≠ÊîæÂèëÈü≥
      if (e.ctrlKey && e.key === "'" && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handlePlayAudio();
        return;
      }

      // Ctrl + M - ÊéåÊè°
      if (e.ctrlKey && e.key === 'm' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleMaster();
        return;
      }

      // Ctrl + N - ÁîüËØç
      if (e.ctrlKey && e.key === 'n' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleNewWord();
        return;
      }

      // Ctrl + S - ÊòæÁ§∫Á≠îÊ°à
      if (e.ctrlKey && e.key === 's' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        handleShowAnswer();
        return;
      }

      // Ctrl + P - ÂàáÊç¢ÊãºÈü≥ÊèêÁ§∫
      if (e.ctrlKey && e.key === 'p' && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        togglePinyinHint();
        return;
      }
    };

    window.addEventListener('keydown', handleShortcutKeys);
    return () => window.removeEventListener('keydown', handleShortcutKeys);
  }, [gameState.gameStarted, handlePlayAudio, handleMaster, handleNewWord, handleShowAnswer, togglePinyinHint, navigate]);

  // È°µÈù¢Á¶ªÂºÄÊó∂Ê∏ÖÁêÜÈü≥È¢ë
  useEffect(() => {
    return () => {
      // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂ÂÅúÊ≠¢ÊâÄÊúâÈü≥È¢ë
      stopAllAudio();
    };
  }, [stopAllAudio]);

  const checkAnswer = useCallback(async () => {
    // ÂÅúÊ≠¢ÂΩìÂâçÊí≠ÊîæÁöÑÈü≥È¢ë
    stopAllAudio();
    
    // ËÆ∞ÂΩïÂÆåÊàêsegment
    if (gameState.currentExerciseId && gameState.currentSegmentId && gameState.segmentStartTime) {
      try {
        const timeSpentSeconds = Math.floor((Date.now() - gameState.segmentStartTime) / 1000);
        await completePractice(
          gameState.currentExerciseId, 
          gameState.currentSegmentId, 
          gameState.practiceMode,
          timeSpentSeconds
        );
        console.log('Successfully completed practice:', gameState.currentSegmentId, 'Time spent:', timeSpentSeconds, 'seconds');
      } catch (error) {
        console.error('Failed to complete practice:', error);
        // ‰∏çÂΩ±ÂìçÊ∏∏ÊàèËøõË°åÔºåÂè™ËÆ∞ÂΩïÈîôËØØ
      }
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàêÂΩìÂâçËØæÁ®ãÁöÑÊâÄÊúâÁªÉ‰π†
    if (allSegments.length > 0) {
      const currentIndex = allSegments.findIndex(ex => ex.id === gameState.currentPhrase?.id);
      const nextIndex = (currentIndex + 1) % allSegments.length;
      
      // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàêÊâÄÊúâÁªÉ‰π†
      const isLastSegment = nextIndex === 0; // Â¶ÇÊûú‰∏ã‰∏Ä‰∏™Á¥¢ÂºïÊòØ0ÔºåËØ¥ÊòéÂ∑≤ÁªèÂÆåÊàêÊâÄÊúâÁªÉ‰π†
      
      if (isLastSegment) {
        // ËØæÁ®ãÂÆåÊàêÔºÅÊòæÁ§∫ÂÆåÊàêÊèêÁ§∫
        setGameState(prev => ({
          ...prev,
          showCourseCompletion: true,
          courseCompleted: true,
          isPlaying: false
        }));
        return; // ‰∏çÁªßÁª≠ÊâßË°åÔºåÁ≠âÂæÖÁî®Êà∑Êìç‰Ωú
      }
      
      const newPhrase = allSegments[nextIndex];
      
      setGameState(prev => ({
        ...prev,
        currentPhrase: {
          content: newPhrase.content || newPhrase.chineseText || '',
          pinyin: newPhrase.pinyin,
          pinyinWithoutTones: newPhrase.pinyinWithoutTones,
          translation: newPhrase.translation || '',
          id: newPhrase.id,
          difficultyLevel: newPhrase.difficultyLevel,
          audioUrl: newPhrase.audioUrl || '',
        },
        userInput: '',
        showResult: false,
        startTime: null,
        isPlaying: false,
        showAnswer: false,
        // Êõ¥Êñ∞segmentÂíåexercise‰ø°ÊÅØ
        currentExerciseId: newPhrase.exerciseId,
        currentSegmentId: newPhrase.id,
        segmentStartTime: Date.now(),
        currentExerciseIndex: newPhrase.exerciseIndex,
      }));
      
      // Ëá™Âä®Êí≠ÊîæÊñ∞È¢òÁõÆÁöÑËØ≠Èü≥‰∏§ÈÅç
      if (newPhrase.audioUrl) {
        setTimeout(() => {
          playAudioTwice(newPhrase.audioUrl!);
        }, 500);
      }
      
      // ËÆ∞ÂΩïËøõÂÖ•Êñ∞ÁöÑsegment
      if (newPhrase.exerciseId && newPhrase.id) {
        try {
          await startPractice(
            newPhrase.exerciseId,  // ‚úÖ ‰ΩøÁî®Êñ∞ÁöÑ exerciseId
            newPhrase.id,          // ‚úÖ ‰ΩøÁî®Êñ∞ÁöÑ segmentId
            gameState.practiceMode
          );
          console.log('Successfully started new practice:', newPhrase.id);
        } catch (error) {
          console.error('Failed to start new practice:', error);
        }
      }
    }
  }, [stopAllAudio, playAudioTwice, allSegments, gameState.currentPhrase?.id, gameState.currentExerciseId, gameState.currentSegmentId, gameState.segmentStartTime, gameState.practiceMode]);

  return (
    <GameContainer>
      <BackButton
        onClick={() => navigate(-1)}
        whileHover={{ scale: 1.05 }}
        whileTap={{ scale: 0.95 }}
      >
        ‚Üê Back
      </BackButton>

      {/* ÈöêËóèÊ®°ÂºèÊåáÁ§∫Âô®ÔºåÁïåÈù¢Êõ¥ÁÆÄÊ¥Å
      <ModeIndicator
        initial={{ opacity: 0, x: 20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.3 }}
      >
        Ê±âÂ≠óÊ®°Âºè
      </ModeIndicator>
      */}

      {gameState.gameStarted && (
        <PinyinToggle
          onClick={togglePinyinHint}
          className={gameState.showPinyinHint ? 'active' : ''}
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.5 }}
        >
          {gameState.showPinyinHint ? 'Hide Pinyin' : 'Show Pinyin'}
        </PinyinToggle>
      )}

      {/* Âä†ËΩΩÁä∂ÊÄÅ */}
      {loading && (
        <ContentArea
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            style={{
              textAlign: 'center',
              color: '#a1a1aa',
              fontSize: '1.1rem'
            }}
          >
            Ê≠£Âú®Âä†ËΩΩÁªÉ‰π†Êï∞ÊçÆ...
          </motion.div>
        </ContentArea>
      )}

      {/* ÈîôËØØÁä∂ÊÄÅ */}
      {error && !loading && (
        <ContentArea
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            style={{
              textAlign: 'center',
              color: '#ef4444',
              fontSize: '1.1rem',
              padding: '20px',
              background: 'rgba(239, 68, 68, 0.1)',
              borderRadius: '12px',
              border: '1px solid rgba(239, 68, 68, 0.3)'
            }}
          >
            {error}
            <br />
            <button
              onClick={() => window.location.reload()}
              style={{
                marginTop: '10px',
                padding: '8px 16px',
                background: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: '6px',
                cursor: 'pointer'
              }}
            >
              ÈáçËØï
            </button>
          </motion.div>
        </ContentArea>
      )}

      {/* Ê∏∏ÊàèÂºÄÂßãÁïåÈù¢ */}
      {!gameState.gameStarted && !loading && !error && allSegments.length > 0 ? (
        <StartScreen
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        >
          <StartTitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.6 }}
          >
            Ready to Start?
          </StartTitle>
          
          <StartSubtitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.6 }}
          >
            Listen and write Chinese characters
          </StartSubtitle>
          
          <KeyHint
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.8, duration: 0.6 }}
          >
            Press Space or Enter to begin
          </KeyHint>
        </StartScreen>
      ) : null}

      {/* ËØæÁ®ãÂÆåÊàêÊèêÁ§∫ÁïåÈù¢ */}
      {gameState.showCourseCompletion && gameState.courseCompleted && (
        <StartScreen
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        >
          <StartTitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.6 }}
            style={{ color: '#22C55E' }}
          >
            üéâ Course Completed!
          </StartTitle>
          
          <StartSubtitle
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.6 }}
          >
            Congratulations! You have successfully completed all exercises in this course.
          </StartSubtitle>
          
          <motion.button
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6, duration: 0.6 }}
            onClick={() => navigate(-1)}
            style={{
              background: 'linear-gradient(135deg, #3B82F6, #8B5CF6)',
              border: 'none',
              borderRadius: '12px',
              padding: '16px 32px',
              color: 'white',
              fontSize: '1.1rem',
              fontWeight: '600',
              cursor: 'pointer',
              transition: 'all 0.3s ease',
              marginTop: '20px'
            }}
            whileHover={{ 
              scale: 1.05,
              boxShadow: '0 8px 25px rgba(59, 130, 246, 0.4)'
            }}
            whileTap={{ scale: 0.95 }}
          >
            ‚Üê Back to Course Package
          </motion.button>
        </StartScreen>
      )}

      {/* Ê∏∏ÊàèÁïåÈù¢ */}
      {gameState.gameStarted && !loading && !error && allSegments.length > 0 && (
        <>
          <GameHint
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3, duration: 0.5 }}
          >
            You can type Chinese characters directly
          </GameHint>
          
          <StatusIndicator
            isActive={gameState.isPlaying}
            animate={{
              scale: gameState.isPlaying ? [1, 1.2, 1] : 1,
            }}
            transition={{
              duration: 1.5,
              repeat: gameState.isPlaying ? Infinity : 0,
            }}
          />
          
          <ContentArea
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ 
              duration: 0.8, 
              ease: "easeOut"
            }}
          >
            {/* Answer display */}
            <AnswerDisplay
              isVisible={gameState.showAnswer}
              phrase={gameState.currentPhrase}
            />

            <ChineseInputSystem
              currentPhrase={gameState.currentPhrase}
              onSubmit={checkAnswer}
              disabled={false}
              showPinyinHint={gameState.showPinyinHint}
              inputMode="chinese"
            />
            
            <AnimatePresence mode="wait">
              {/* Removed ScoreBoard display for simplified game experience */}
            </AnimatePresence>
          </ContentArea>
          
          {/* Bottom shortcut bar */}
          <BottomShortcutBar
            onPlayAudio={handlePlayAudio}
            onMaster={handleMaster}
            onNewWord={handleNewWord}
            onSubmit={handleSubmitShortcut}
            onShowAnswer={handleShowAnswer}
            onSkip={handleSkip}
            mode="chinese"
            onTogglePinyinHint={togglePinyinHint}
          />
        </>
      )}
    </GameContainer>
  );
};